import json
import os.path
import sys
import re

# global for storing dictionary of output strings (which reduces redundancy in code execution)
outputStringsDict = {}
exportedJson = ""
baseClassTypeList = []
baseClassTypeList.append("CrusadersGame.Defs.CrusadersGameDataSet")
baseClassTypeList.append("UnityGameEngine.Dialogs.DialogManager")
baseClassTypeList.append("UnityGameEngine.Core.EngineSettings")
baseClassTypeList.append("IdleGameManager")
baseClassTypeList.append("CrusadersGame.GameSettings")
baseClassTypeList.append("CrusadersGame.Effects.OminContractualObligationsHandler")
baseClassTypeList.append("TimeScaleWhenNotAttackedHandler")
baseClassTypeList.append("CrusadersGame.Effects.HavilarImpHandler")
baseClassTypeList.append("CrusadersGame.Effects.BrivUnnaturalHasteHandler")

# Main
def main():
    memoryStructureLoc = ".\\ScriptHubExport32.json"
    StartImport(memoryStructureLoc, False)
    memoryStructureLoc = ".\\ScriptHubExport64.json"
    StartImport(memoryStructureLoc, True)
    return

# Read json file exported from CE ScriptHubExporter addon and import from files based on types
def StartImport(memFileLoc, is64Bit):
    global exportedJson
    global baseClassTypeList
    if os.path.exists(memFileLoc):
        jsonFile = open(memFileLoc, 'r')
        exportedJson = json.load(jsonFile)
        jsonFile.close()
        # get classes object    
        exportedJson = exportedJson['classes']
        # set the base class starting point (object the base pointer points to)
        # filename is based on the last chunk
        # e.g. CrusadersGame.Defs.CrusadersGameDataSet will check MemoryLocations_CrusadersGameDataSet.txt for offset lookup items.
        for baseClassType in baseClassTypeList:
            Import(baseClassType, is64Bit)
    else:
        print("Could not open " + memFileLoc + ". It does not exist.")
    return

# Reads MemoryLocations file for target variables and builds them into ScriptHub import code (AHK).
def Import(baseClass, is64Bit = False):
    global exportedJson
    # Make sure output is clear before doing an import
    global outputStringsDict
    outputStringsDict = {}
    # read input file with list of offsets to find
    memoryFile = ""
    baseClassParts = baseClass.split('.')
    fileNameBase = baseClassParts[len(baseClassParts) - 1]
    memoryFileLocation = ".\\MemoryLocations_" + fileNameBase + ".txt"
    if os.path.exists(memoryFileLocation):
        memoryFile = open(memoryFileLocation, 'r')
    else:
        print("Could not open " + memoryFileLocation + ". It does not exist.")
        return
    # read lines from text file without newline breaks
    memoryFileLines = memoryFile.read().splitlines() 
    memoryFile.close()
    # remove empty strings
    memoryFileLines = [i for i in memoryFileLines if i != '']
    # remove commented lines
    memoryFileLines = [i for i in memoryFileLines if i[0] != '#']

    # iterate lines and build ahk file to outputStringsDict
    for line in memoryFileLines:
        offsetsLocationStringSplit = line.split(".")
        BuildMemoryString(baseClass, offsetsLocationStringSplit, 0) 
    version = "64" if is64Bit else "32"
    OutputImportToFile(fileNameBase, version)
    outputStringsDict = {}
    print(baseClass + " " + version + "bit output complete.")
    return

# Writes outputStringsDict to the appropriate file.
def OutputImportToFile(fileNameBase, version):
    # Output to AHK file
    memoryFileString = "; This file was automatically generated by ScriptHubImporter.py\n"
    for k,v in outputStringsDict.items():
        memoryFileString = memoryFileString + v
    outputFile = open(".\\Imports\\IC_" + fileNameBase + version + "_Import.ahk", 'w')
    outputFile.write(memoryFileString)
    outputFile.close()
    return

# recursive function that will search for the current indexValue of variablesStringArray and call itself for the rest of the variables in variablesStringArray
# appending strings for final output as it goes
def BuildMemoryString(classType, variablesStringArray, indexValue, checkParent = True):
    global exportedJson
    isFound = False
    if indexValue >= len(variablesStringArray):
        return isFound
    if classType == "System.Object":
        return isFound
    if classType == "CrusadersGame.Effects.IEffectSource":
        return isFound
    classTypeOriginal = classType
    #fix for timescale using GameManager (IdleGameManager extends GameManager) instead of its starting top level of IdleGameManager
    if classType == "GameManager":
        classTypeOriginal = "IdleGameManager"
    # could not find the class, test for variation with + (e.g. 'CrusadersGame.User.UserModronHandler.ModronCoreData' -> 'CrusadersGame.User.UserModronHandler+ModronCoreData') 
    if classType not in exportedJson:
        subClassCheckString = '+'.join(classType.rsplit('.',1))
        if subClassCheckString in exportedJson:
            classType = subClassCheckString 
    # class still not found, lookup failed. Pass.
    if classType not in exportedJson:
        NotificationForMissingClass(variablesStringArray, indexValue)
        return isFound

    # could not find the variable in the class (Check parent classes?)
    if variablesStringArray[indexValue] not in exportedJson[classType]['fields']:
        # Check special cases of collections that include derived objects
        isFound = SpecialSubClassCaseCheck(classType, variablesStringArray, indexValue)
        # otherwise, check the parent class
        if checkParent and not isFound:
            isFound = BuildMemoryString(exportedJson[classType]['Parent'], variablesStringArray, indexValue)
        if isFound:
            return
        elif checkParent:        
            NotificationForMissingFields(classType, variablesStringArray, indexValue)
        return isFound


    # ================================================================
    # passed checks, set variables
    isFound = True
    offset = hex(int(exportedJson[classType]['fields'][variablesStringArray[indexValue]]['offset']))
    static = exportedJson[classType]['fields'][variablesStringArray[indexValue]]['static']
    classType = exportedJson[classType]['fields'][variablesStringArray[indexValue]]['type']
    
    # list/dict test
    # TODO: Determine list vs Dict
    # TODO: TransitionOverride dictionary using action?
    # TODO: Handle Dictionary<List<Action<>>> types (TransitionOverride) | list<list<CrusadersGame.Dialog>> (Dialogs)
    match = re.search(".*<", classType)
    if match is not None:
        preMatch = match.group(0)
        preMatch = preMatch[:-1]

        # test for sub-types (more <>)
        # if found, add current type to output
        # otherwise continue
        
    currClassType = classType
    lastClassType = classType
    while True:
        # regular expression to find if part of the string is wrapped in angle brackets       
        match = re.search("<.*>", currClassType)
        if match is None:
            break
        lastClassType = currClassType
        currClassType = match.group(0)
        # remove angle brackets
        currClassType = currClassType[1:-1]
        # TODO: Store list of types and get last one that matches dict/hashset/list/other?
    varType = GetMemoryTypeFromClassType(currClassType, lastClassType)
    # Fixes:
    # TODO: Fix effectKeysByKeyName from list to dict | Dictionary<string, List<EffectKey>> effectKeysByKeyName
    # AHK Can't handle <> in names, such as k__BackingField
    if variablesStringArray[indexValue].find("k__BackingField") >= 0:
        match = re.search("<.*>", variablesStringArray[indexValue])
        match = match.group(0)
        match = match[1:-1]
        variablesStringArray[indexValue] = match + "_k__BackingField"
    
    # True location of int value from ProtectedInt
    if currClassType == "UnityGameEngine.Utilities.ProtectedInt":
        offset = hex(int(offset, 16) + int('0x8', 16))

    indexValue += 1
    # add new value to dictionary if it is not already there, then build next value
    fullNameOfCurrentVariable = '.'.join(variablesStringArray[:indexValue])
    if fullNameOfCurrentVariable not in outputStringsDict:
        parentValue = '.'.join(variablesStringArray[:indexValue-1]) if indexValue > 1 else classTypeOriginal 
        if static == "false":
            outputStringsDict[fullNameOfCurrentVariable] = "this." + fullNameOfCurrentVariable + " := New GameObjectStructure(this." + parentValue + ",\"" + varType + "\", [" + str(offset) + "])\n"
        else:
            outputStringsDict[fullNameOfCurrentVariable] = "this." + fullNameOfCurrentVariable + " := New GameObjectStructure(this." + parentValue + ",\"" + varType + "\", [this.StaticOffset + " + str(offset) + "])\n"
    BuildMemoryString(currClassType, variablesStringArray, indexValue) 
    return isFound

# For cases where there is a collection of a base class that can contain objects that may be sub classes of the base class.
# If the object is not found in the base class, check the derived class, but not its parents.
def SpecialSubClassCaseCheck(classType, variablesStringArray, indexValue):
    isFound = False
    if classType == "UnityGameEngine.Dialogs.Dialog":
        isFound = BuildMemoryString( "CrusadersGame.Dialogs.BlessingsStore.BlessingsStoreDialog", variablesStringArray, indexValue, False) or BuildMemoryString(exportedJson[classType]['Parent'], variablesStringArray, indexValue)

    return isFound
def NotificationForMissingClass(variablesStringArray, indexValue):
    appended = ""
    if indexValue+1 < (len(variablesStringArray)):
        appended = "." + '.'.join(variablesStringArray[indexValue+1:])
    variableInQuestion = '.'.join(variablesStringArray[:indexValue]) + ".[" + variablesStringArray[indexValue] + "]" + appended
    print("Class \"" + classType + "\" not found when looking up " + variableInQuestion + ". Continuing...")

# When a field is not found, print a messsage displaying suggested alternative (if available), as well as the offending offset.
def NotificationForMissingFields(classType, variablesStringArray, indexValue):
    # When the class is still not found, test for case mis-match and print alert if found
    for fieldName in exportedJson[classType]['fields']:
        if variablesStringArray[indexValue].lower() == fieldName.lower():
            print("Did you mean \'" + fieldName + "'?")
            break
    # show diagnostic info for failure to find variable
    print("Variable " + variablesStringArray[indexValue] + " not found in class " + classType + ". Checking Parent (" + exportedJson[classType]['Parent'] + ")...")
    appended = ""
    if indexValue+1 < (len(variablesStringArray)):
        appended = "." + '.'.join(variablesStringArray[indexValue+1:])
    print('.'.join(variablesStringArray[:indexValue]) + ".[" + variablesStringArray[indexValue] + "]" + appended)

# Given a class type, return the memory read type to be used.
def GetMemoryTypeFromClassType(classType, lastClassType):
    # TODO: iterate through list of types from above check if they are in the non System.x classes in the json
    #       i.e. no int/string/dictionary/list/hashset
    #       if they are not, check next highest. 
    #       if none are, use the first item 
    #       e.g. Dictionary<List<Action<Action>>> would ignore action/list and become dictionary    

    if re.search("List", lastClassType):
        return "List"
    elif re.search("Dictionary", lastClassType):
        return "Dict"
    elif re.search("HashSet", lastClassType):
        return "HashSet"

    # read class type and pick appropriate type for memory reading
    varType = ""
    if classType == "System.Int32":
        varType = "Int"
    elif classType == "System.Boolean":
        varType = "Char"
    elif classType == "System.String":
        varType = "UTF-16"
    elif classType == "System.Double":
        varType = "Double"
    elif classType == "System.Single":
        varType = "Float"
    elif classType == "Engine.Numeric.Quad":
        varType = "Quad"                        # actually 2 sequential Int64
    elif classType == "UnityGameEngine.Utilities.ProtectedInt":
        varType = "Int"
    else:
        varType = "Int"
    return varType

if __name__ == "__main__":
    main()